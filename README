★English as a programming language★

A revolution will break loose. Soon every English speaker will be able to completely control their devices via voice. people will realize that by giving their devices commands which should be performed at specific times they are actually programming them. Now imagine you could not just say “remind me to take out the trash next Sunday”, But also complicated sequences like:
Here is what you do when I enter my office
You switch on the coffee machine
You request the status report from all employees who haven't submitted the status report Voluntarily.
< Replace this example >

While Siri is already great for retrieving information it falls a bit short in accessing some of the phones capabilities. In some of the existing assistants on android you can already say things like “enable Bluetooth, turn down the volume, open speech input settings” etc.
But this is only the first step in the evolution of speech control.

Next you will not only be able to control some specific ★ but also most of all applications on your device. Of course this requires the operating systems to specify mechanisms in which applications can promote their abilities. In a Narrow way this is already done with Dragon NaturallySpeaking on Windows machines, where you can access all the functionality which is accessible through the menus by speech. a broader approach will allow applications to reveal patterns , Phrases or keywords for which they can provide a useful action. Alternatively the speech input flow will be forwarded To the active application which can then decide to do something useful with it or not itself.

After that or maybe in parallel the really interesting change in paradigms will occur: people will not only be able to completely control everything they see on their screen by voice but they will also be able to control the future state of their device first by Single sentences like “enable airplane mode whenever I enter an airplane”. Then by whole sequences of commands, which should be seen as programs or algorithms. Now all the hacker mind needs is a –functionality complete– set of speakable structures and the fun can really begin:

Fictional examples
0) Simple-most examples

How to make a beep
Print Character 7
Done

How to check if someone is online on Skype
Call java Skype.checkStaus(Someone)
Return yes If Result equals "online"
Return no otherwise
Done

While Peter is online on Skype
Make a beep
Sleep for 10 seconds
Done

1) Simple
Whenever I received an email, You check if it's Sender is my girlfriend.
If so, You turn the light bulb in the living room green until I clap my hand.

Doesn't it remind you of apple action script?
It should, because action script is the predecessor of real speakable programming languages. But in this example you see many components which are not part of action script yet, even though it has a remarkably advanced language:
◦'Whenever' keywords, to connect a programming block to the event notification system.
◦'My' Keyword to access the synchronized user graph
◦ Even Listeners and triggers, “Clap my hand”, to be specified in other programming blocks.
◦ Clarification dialogs: If one of the mentioned objects or events is unknown, the system can ask things like:
Who is your girlfriend
How do I know when you clap your hands

A simple clarification system is already part of AIML and a bit more advanced in Jeannie.

◦ Eventually a simple API to connect all existing c code with this  driven model, For example you could ride a little handclapping detection engine in c and then whenever a handclap occurs you'll invoke EnglishScriptEvent("my.hand.clap") Or to be more precise English script event SPO("me clap me.hand")
Our engine of cost should be semantically smart enough to match "I clip my hand" against this event.
◦ We not only have a Personal graph for the 'my/me/I' keyword but also a generous active graph for objects around you: "bulb[green]@room[living]". The bulb object needs to have a method ‘turn green’.

This seems like many steps in one and one could demand that we first introduce these features in an existing language like Ruby. This dust in fact appear like a feasible intermediate step.
To summarize the requested features are:
A personnel and Genereaux object graph with attached methods.
Hey slightly semantic event system, With a simple syntax to connect with listeners: once(<enent>) do <block> end
The only objection here is that this is so trivial that it takes the fun out of it but we will just do that To get warm.


Difficulties in first implementations of such a system

Users a.k.a. speakers of such a programming language will have the inherent problem of expecting too much.
They r very prone to forgetting that in the beginning they can only dictate a certain subset of English.
Even if the syntax is in accordance with the specific grammar users might be disappointed that the parsed command “Find me $1 million” Might not you the results they expect. Some people argue that this is a reason why very mathematical languages like c will never get replaced by More verbose languages. And they arrived you probably don't want to write a kernel driver in English for a very long time. But still the use cases far English as a programming language arts so incredibly huge and universal that they will likely put old-fashioned languages into the ★shadow★ very quickly despite of their shortcomings.

Ambiguities

“Whenever he objects to the object lead him to the lead in the truth.”

This problem may appear big in the beginning but can be solved by conservative programming language mechanisms: put brackets around groups, And annotate resolved ambiguities.

(Whenever trigger=((he.lastref=peter) (object-to4) ("object".lastref=xyz)) action=(do-lead to truth.lead))

If you have some decency you find the converted text horrible. but that's okay, Even though there is no way around an internal representation which might have this lisp like flavour, there is almost no need to ever reviewl it to the programmer.

You probably don't want your code to be cluttered with braces brackets and hyperlinks for the concepts, so what we need is an IDE which will hide the details unless being inspected.

There are several paths in which this can be achieved:
1) Get the proposed system running in Ruby as discussed earlier. Then create a parser which translates our beautiful English into hopefully not that ugly ruby/java/lisp code.
2) Crate an annotation system which will resolve the issues around the text
3) Craig a proper representation Language which is sufficiently beautiful and deterministic. Parse every input sentence to that representation. For portability write down the original English and the interpretation next to each other when sending the file along. Reinterpret the English sentence whenever it is changed, Maybe taking into consideration's manual modifications to the representation if they Did Oakar.
4) Ask the user to resolve this ambiguities when entering the phrase and then just compile the interpretation down to byte coat. This is the biggest disadvantage that a user might have picked the wrong resolution Blenhem Tehuti and will not see this error directly anymore.
5) Have a lightweight disambiguation inside English only when necessary:

“Whenever (he objects to the object) (lead him to (the lead in the truth))”

This has the big advantage of being perfectly readable yet having the property of being parsable in a deterministic way.
Maybe operator binding can make many braces unnecessary. however it's always the task of the compiler to suggest and insert the braces. Should the system for some reason become certain about whats the disambiguation of the parsetree, it can remove the braces itself.

★Blocks★
Just a quick reminder this is how blocks look like in Ruby:
7.Times do
prints "I am happy"
End

Blocks can be opened in many different ways. we want to add the following keywords or scenarios to the existing ruby blocks:
Once (trigger condition) do (block) end
As long as...
Infinitly do ...
As soon as ...
Repeat the following...
And many more.

You might have noted that some of the keywords are redundant. we believe that this is not a bad thing.

We want to give the program a bit more natural flexibility when it comes to ending blocks thus we also allow "done" "thats it" "ok" And other keywords to denote the ending of the block.

How to make a beep
Println(0x0a)
Done

Preferably long blocks can be ended by naturally annotating what the block was about:

how to calculate the volume of a mesh object:
// Long calculation block goes here
Done calculating the volume

★Implementation★
As we pointed out There are different paths how this language can be put into existence. Therefore there are many possible different intimidations. Infect what we should do first is clearly specify the syntax limitations and the desired features of our language.

One good way of doing this is through a grammar specification language/tool, for example ANTLR.
< Copy paste nice examples>

We can also create syntax highlighting to distinguish the structural Keywords are patterns from free "subject predicate object method calls" like: (computer) purge trash!
There is a lot we can learn and from AppleScript here.

★ Experience and Experiments★
So far we did create semantic graphs which satisfies our needs. We started to write the first Verizon off the grammar for English script. However we did run into the limitations of antler. Specifically it's inability to include large sets in a natural way.
We have a work list of English burps and naturally we wanted to include them in our grammar:
To show the problem in a simplified way
Statement: If condition then action.
Action: verb (the) noun
Forget for a moment that many verbs are also nouns and vice versa, we couldn't even include a list of verbs. It is easy to create a list of 20 burps but our list of 50,000 words just made the compiler crash.
 when we started to get into the in workings of antler we soon found out that the whole system is based on a character-centric state machine instead of a word state machine. This may create Larry efficient machines for parsers of arbitrary strings sets. However in our case we have cleanly tokenized strings sets and optimizing the parser by grouping different words until little subtrees just makes the code unreadable.

To illustrate the difference:
Let's say our grammar has three different patterns:
Begin to action
Before condition action


what we want is some parser generator which creates something along the lines
Switch(firstWord)
Case begin: ...
Case before: ...

What Antlr produces is very different and horrible indeed:
Switch firstWhatever:
Case be:
 Switch nextBla
 Case gin:
 Case ore:
Case c3

 this is a good solution to a set of problems which, unfortunately, is distinct from our problem.
We didn't contact Terrence the great Mastermind behind ANTLR yet, In order to ask him what it would take to create a word centric version of antler. Our fear is that something new and clean has to be designed from the ground up. It might not be rocket science but it could be a good load of hard work, deep thinking and many sideways and mistakes involved.
That's just for the proper parser, Which ideally should be able to have semantic flow control as well, Similarily to what is already possible in anstler.
"Ideally" is an understatement, it will become a necessity in the process.
To those naysayers saying that draping a parser or even a grammar for English is impossible:
First we don't want to parse the whole richness of English
Secondly we can assume a cooperative user so whenever the Parsler is not sure what to do the user can assist
Thirdly modern C++ parsers probably have a much higher complexity of what we want to achieve

And lastly (this is only partly a joke and should illustrate some limitations of grandma theory): if we say that each statement has to be less then 100 Wurts we are not faced with a class 0 language but with a class four Grammar, namely a finite set of commands. Of course the practical truth lies in between.
